#if UNITY_NETWORKING
using Unity.Netcode;
#endif
using UnityEngine;

#ROOTNAMESPACEBEGIN#
{
    /// <summary>
    ///     A static instance is similar to a singleton, but instead of destroying any new
    ///     instances, it overrides the current instance. This is handy for resetting the state
    ///     and saves you doing it manually.
    /// </summary>
    public abstract class StaticInstance<T> : MonoBehaviour where T : MonoBehaviour
    {
        private static T _instance;

        public static bool HasInstance => _instance != null;
        public static T TryGetInstance() => HasInstance ? _instance : null;

        public static T Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = FindAnyObjectByType<T>();
                    if (_instance == null)
                    {
                        var go = new GameObject(typeof(T).Name + " Auto-Generated");
                        _instance = go.AddComponent<T>();
                        Debug.Log($"Auto-generated instance of {typeof(T).Name}");
                    }
                }

                return _instance;
            }

            private set => _instance = value;
        }

        /// <summary>
        /// Initialize the singleton.
        /// When overriding in derived classes, always call base.Awake() first
        /// to ensure proper singleton initialization.
        /// </summary>
        protected virtual void Awake()
        {
            InitializeSingleton();
        }

        protected virtual void InitializeSingleton()
        {
            if (!Application.isPlaying) return;

            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this as T;
        }

        protected void OnApplicationQuit()
        {
            Instance = null;
            Destroy(gameObject);
        }
    }

    /// <summary>
    ///     This transforms the static instance into a basic singleton.
    ///     This will destroy any new versions created, leaving the original instance intact.
    /// </summary>
    public abstract class Singleton<T> : StaticInstance<T> where T : MonoBehaviour
    {
        /// <summary>
        /// Initialize the singleton.
        /// When overriding in derived classes, always call base.Awake() first
        /// to ensure proper singleton initialization.
        /// </summary>
        protected override void InitializeSingleton()
        {
            if (!Application.isPlaying) return;
            
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            base.InitializeSingleton();
        }
    }

    /// <summary>
    ///     A persistent version of the singleton. This will survive through scene loads.
    ///     Perfect for system classes which require stateful, persistent data. Or audio sources
    ///     where music plays through loading screens, etc.
    /// </summary>
    public abstract class PersistentSingleton<T> : Singleton<T> where T : MonoBehaviour
    {
        /// <summary>
        /// When true, the GameObject will be unparented during initialization
        /// </summary>
        public bool AutoUnparentOnAwake = true;

        /// <summary>
        /// Initialize the persistent singleton.
        /// When overriding in derived classes, always call base.Awake() first
        /// to ensure proper singleton initialization.
        /// </summary>
        protected override void InitializeSingleton()
        {
            if (!Application.isPlaying) return;
            
            if (AutoUnparentOnAwake)
            {
                transform.SetParent(null);
            }

            base.InitializeSingleton();
            DontDestroyOnLoad(gameObject);
        }
    }

    /// <summary>
    /// Regulator singleton will destroy any older components of the same type it finds on awake
    /// Ensures that only the most recently created instance survives
    /// </summary>
    public abstract class RegulatorSingleton<T> : StaticInstance<T> where T : MonoBehaviour
    {
        public float InitializationTime { get; private set; }

        /// <summary>
        /// Initialize the regulator singleton.
        /// When overriding in derived classes, always call base.Awake() first
        /// to ensure proper singleton initialization.
        /// </summary>
        protected override void InitializeSingleton()
        {
            if (!Application.isPlaying) return;

            InitializationTime = Time.time;
            DontDestroyOnLoad(gameObject);

            // Find and destroy older instances
            T[] allInstances = FindObjectsByType<T>(FindObjectsSortMode.None);
            foreach (T found in allInstances)
            {
                if (found != this)
                {
                    var regulator = found.GetComponent<RegulatorSingleton<T>>();
                    if (regulator != null && regulator.InitializationTime < InitializationTime)
                    {
                        Destroy(found.gameObject);
                    }
                }
            }

            base.InitializeSingleton();
        }
    }

#if UNITY_NETWORKING
    /// <summary>
    ///     A static instance is similar to a singleton, but instead of destroying any new
    ///     instances, it overrides the current instance. This is handy for resetting the state
    ///     and saves you doing it manually. But now networked!
    /// </summary>
    public abstract class NetworkSingleton<T> : NetworkBehaviour where T : NetworkBehaviour
    {
        private static T _instance;
        
        public static bool HasInstance => _instance != null;
        public static T TryGetInstance() => HasInstance ? _instance : null;
        
        public static T Instance 
        { 
            get
            {
                if (_instance == null)
                {
                    _instance = FindAnyObjectByType<T>();
                    if (_instance == null)
                    {
                        var go = new GameObject(typeof(T).Name + " Auto-Generated");
                        _instance = go.AddComponent<T>();
                        Debug.Log($"Auto-generated network instance of {typeof(T).Name}");
                    }
                }
                return _instance;
            }
            private set => _instance = value;
        }

        /// <summary>
        /// Initialize the network singleton.
        /// When overriding in derived classes, always call base.Awake() first
        /// to ensure proper singleton initialization.
        /// </summary>
        protected virtual void Awake()
        {
            InitializeSingleton();
        }

        protected virtual void InitializeSingleton()
        {
            if (!Application.isPlaying) return;

            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this as T;
        }

        protected void OnApplicationQuit()
        {
            Instance = null;
            Destroy(gameObject);
        }
    }
#endif
#ROOTNAMESPACEND#
